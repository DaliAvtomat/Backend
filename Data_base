CREATE SCHEMA cinema;

-- 1. СУЩНОСТЬ РЕАЛЬНОГО МИРА: ПОЛЬЗОВАТЕЛЬ
CREATE TABLE cinema.user (
    id SERIAL PRIMARY KEY,
    name VARCHAR(15) NOT NULL CONSTRAINT user_name_length CHECK (LENGTH(name) BETWEEN 1 AND 15),
    email VARCHAR(255) NOT NULL UNIQUE CONSTRAINT valid_email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    password_hash VARCHAR(255) NOT NULL,
    is_active BOOLEAN DEFAULT FALSE,
    registered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    profile_picture VARCHAR(255) DEFAULT '',
    overall_rating DECIMAL(3,2) DEFAULT 0.00 CONSTRAINT user_rating_range CHECK (overall_rating >= 0 AND overall_rating <= 10)
);

-- 2. СУЩНОСТЬ РЕАЛЬНОГО МИРА: ФИЛЬМ
CREATE TABLE cinema.movie (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    duration INT CONSTRAINT positive_duration CHECK (duration > 0),
    release_year INT CONSTRAINT valid_release_year CHECK (release_year BETWEEN 1888 AND EXTRACT(YEAR FROM CURRENT_DATE) + 5),
    poster_url VARCHAR(255)
);

-- 3. СУЩНОСТЬ РЕАЛЬНОГО МИРА: КОМНАТА
CREATE TABLE cinema.room (
    id SERIAL PRIMARY KEY,
    name VARCHAR(15) NOT NULL CONSTRAINT room_name_length CHECK (LENGTH(name) BETWEEN 1 AND 15),
    owner_id INT NOT NULL REFERENCES cinema.user(id) ON DELETE CASCADE ON UPDATE CASCADE,
    status VARCHAR(15) NOT NULL DEFAULT 'collecting' CONSTRAINT valid_status CHECK (status IN ('collecting', 'roulette', 'watching', 'reviewing', 'finished')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    roulette_starts_at TIMESTAMP,
    watching_starts_at TIMESTAMP,
    review_ends_at TIMESTAMP,
    selected_movie_id INT REFERENCES cinema.movie(id) ON DELETE SET NULL ON UPDATE CASCADE,
    selected_user_id INT REFERENCES cinema.user(id) ON DELETE SET NULL ON UPDATE CASCADE,
    is_open BOOLEAN DEFAULT TRUE,
    access_code VARCHAR(7) CONSTRAINT access_code_length CHECK (LENGTH(access_code) BETWEEN 4 AND 7),
    CONSTRAINT logical_timeline CHECK (
        (roulette_starts_at IS NULL OR created_at <= roulette_starts_at) AND
        (watching_starts_at IS NULL OR roulette_starts_at <= watching_starts_at) AND
        (review_ends_at IS NULL OR watching_starts_at <= review_ends_at)
    ),
    CONSTRAINT selected_movie_consistency CHECK (
        (selected_movie_id IS NOT NULL AND status IN ('watching', 'reviewing', 'finished')) OR
        (selected_movie_id IS NULL AND status IN ('collecting', 'roulette'))
    )
);

-- 4. УЧАСТНИКИ КОМНАТЫ
CREATE TABLE cinema.room_participant (
    id SERIAL PRIMARY KEY,
    room_id INT NOT NULL REFERENCES cinema.room(id) ON DELETE CASCADE ON UPDATE CASCADE,
    user_id INT NOT NULL REFERENCES cinema.user(id) ON DELETE CASCADE ON UPDATE CASCADE,
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    left_at TIMESTAMP,
    role VARCHAR(10) DEFAULT 'member' CONSTRAINT valid_role CHECK (role IN ('member', 'moderator')),
    is_active BOOLEAN DEFAULT TRUE,
    CONSTRAINT logical_join_leave CHECK (joined_at <= left_at OR left_at IS NULL)
);

-- Partial unique index для активных участников
CREATE UNIQUE INDEX unique_active_room_user ON cinema.room_participant (room_id, user_id) WHERE is_active = TRUE;

-- 5. ПРЕДЛОЖЕННЫЕ ФИЛЬМЫ
CREATE TABLE cinema.suggested_movie (
    id SERIAL PRIMARY KEY,
    movie_id INT NOT NULL REFERENCES cinema.movie(id) ON DELETE CASCADE ON UPDATE CASCADE,
    room_id INT NOT NULL REFERENCES cinema.room(id) ON DELETE CASCADE ON UPDATE CASCADE,
    user_id INT NOT NULL REFERENCES cinema.user(id) ON DELETE CASCADE ON UPDATE CASCADE,
    suggested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    in_roulette BOOLEAN DEFAULT TRUE
);

-- Partial unique index для активных предложений
CREATE UNIQUE INDEX unique_active_suggestion ON cinema.suggested_movie (room_id, user_id) WHERE is_active = TRUE;

-- 6. ИСТОРИЯ РУЛЕТКИ
CREATE TABLE cinema.roulette_history (
    id SERIAL PRIMARY KEY,
    room_id INT NOT NULL REFERENCES cinema.room(id) ON DELETE CASCADE ON UPDATE CASCADE,
    selected_movie_id INT NOT NULL REFERENCES cinema.movie(id) ON DELETE CASCADE ON UPDATE CASCADE,
    selected_user_id INT NOT NULL REFERENCES cinema.user(id) ON DELETE CASCADE ON UPDATE CASCADE,
    candidates_count INT NOT NULL CONSTRAINT positive_candidates CHECK (candidates_count > 0),
    roulette_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    spin_duration INT CONSTRAINT positive_spin_duration CHECK (spin_duration > 0)
);

-- 7. ОТЗЫВЫ И ОЦЕНКИ
CREATE TABLE cinema.review (
    id SERIAL PRIMARY KEY,
    movie_id INT NOT NULL REFERENCES cinema.movie(id) ON DELETE CASCADE ON UPDATE CASCADE,
    room_id INT NOT NULL REFERENCES cinema.room(id) ON DELETE CASCADE ON UPDATE CASCADE,
    from_user_id INT NOT NULL REFERENCES cinema.user(id) ON DELETE CASCADE ON UPDATE CASCADE,
    to_user_id INT NOT NULL REFERENCES cinema.user(id) ON DELETE CASCADE ON UPDATE CASCADE,
    rating INT NOT NULL CONSTRAINT valid_rating CHECK (rating BETWEEN 1 AND 10),
    comment TEXT,
    reviewed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT no_self_review CHECK (from_user_id != to_user_id)
);

CREATE UNIQUE INDEX unique_review_per_movie ON cinema.review (movie_id, room_id, from_user_id);

-- 8. ЖАНРЫ ФИЛЬМОВ
CREATE TABLE cinema.genre (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT
);

-- 9. СВЯЗЬ ФИЛЬМОВ И ЖАНРОВ
CREATE TABLE cinema.movie_genre (
    id SERIAL PRIMARY KEY,
    movie_id INT NOT NULL REFERENCES cinema.movie(id) ON DELETE CASCADE ON UPDATE CASCADE,
    genre_id INT NOT NULL REFERENCES cinema.genre(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT unique_movie_genre UNIQUE (movie_id, genre_id)
);

-- 10. ИСТОРИЯ СЕАНСОВ
CREATE TABLE cinema.session_history (
    id SERIAL PRIMARY KEY,
    room_id INT NOT NULL REFERENCES cinema.room(id) ON DELETE CASCADE ON UPDATE CASCADE,
    movie_id INT NOT NULL REFERENCES cinema.movie(id) ON DELETE CASCADE ON UPDATE CASCADE,
    suggested_by_user_id INT NOT NULL REFERENCES cinema.user(id) ON DELETE CASCADE ON UPDATE CASCADE,
    watched_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    participants_count INT DEFAULT 0 CONSTRAINT non_negative_participants CHECK (participants_count >= 0),
    average_rating DECIMAL(3,2) CONSTRAINT valid_avg_rating CHECK (average_rating >= 0 AND average_rating <= 10),
    total_reviews INT DEFAULT 0 CONSTRAINT non_negative_reviews CHECK (total_reviews >= 0)
);

-- 11. УВЕДОМЛЕНИЯ
CREATE TABLE cinema.notification (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL REFERENCES cinema.user(id) ON DELETE CASCADE ON UPDATE CASCADE,
    room_id INT REFERENCES cinema.room(id) ON DELETE CASCADE ON UPDATE CASCADE,
    title VARCHAR(100) NOT NULL,
    message TEXT NOT NULL,
    type VARCHAR(20) CONSTRAINT valid_notification_type CHECK (type IN ('invite', 'roulette_start', 'movie_selected', 'review_time', 'room_ended')),
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 12. СТАТИСТИКА ПОЛЬЗОВАТЕЛЕЙ
CREATE TABLE cinema.user_statistic (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL UNIQUE REFERENCES cinema.user(id) ON DELETE CASCADE ON UPDATE CASCADE,
    movies_suggested INT DEFAULT 0 CONSTRAINT non_negative_suggested CHECK (movies_suggested >= 0),
    movies_selected INT DEFAULT 0 CONSTRAINT non_negative_selected CHECK (movies_selected >= 0),
    total_ratings_received INT DEFAULT 0 CONSTRAINT non_negative_ratings CHECK (total_ratings_received >= 0),
    last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 13. ТАБЛИЦА ЧАТА КОМНАТЫ
CREATE TABLE cinema.room_chat (
    id SERIAL PRIMARY KEY,
    room_id INT NOT NULL REFERENCES cinema.room(id) ON DELETE CASCADE ON UPDATE CASCADE,
    user_id INT NOT NULL REFERENCES cinema.user(id) ON DELETE CASCADE ON UPDATE CASCADE,
    message TEXT NOT NULL CONSTRAINT non_empty_message CHECK (LENGTH(TRIM(message)) > 0),
    sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    message_type VARCHAR(20) DEFAULT 'text' CONSTRAINT valid_message_type CHECK (message_type IN ('text', 'system', 'event')),
    reply_to_id INT REFERENCES cinema.room_chat(id) ON DELETE SET NULL,
    is_edited BOOLEAN DEFAULT FALSE,
    edited_at TIMESTAMP
);

-- Индексы для производительности
CREATE INDEX idx_room_status ON cinema.room(status);
CREATE INDEX idx_room_owner ON cinema.room(owner_id);
CREATE INDEX idx_movie_title ON cinema.movie(title);
CREATE INDEX idx_review_rating ON cinema.review(rating);
CREATE INDEX idx_user_email ON cinema.user(email);
CREATE INDEX idx_suggested_movie_room ON cinema.suggested_movie(room_id);
CREATE INDEX idx_room_participant_active ON cinema.room_participant(is_active);
CREATE INDEX idx_suggested_movie_active ON cinema.suggested_movie(is_active);
CREATE INDEX idx_roulette_history_room ON cinema.roulette_history(room_id);
CREATE INDEX idx_review_to_user ON cinema.review(to_user_id);
CREATE INDEX idx_room_participant_user ON cinema.room_participant(user_id);
CREATE INDEX idx_room_participant_room_user ON cinema.room_participant(room_id, user_id);
CREATE INDEX idx_suggested_movie_user ON cinema.suggested_movie(user_id);
CREATE INDEX idx_review_from_user ON cinema.review(from_user_id);
CREATE INDEX idx_review_movie_room ON cinema.review(movie_id, room_id);
CREATE INDEX idx_room_created_at ON cinema.room(created_at);
CREATE INDEX idx_notification_user_unread ON cinema.notification(user_id, is_read);
CREATE INDEX idx_room_chat_room ON cinema.room_chat(room_id);
CREATE INDEX idx_room_chat_timestamp ON cinema.room_chat(sent_at);
CREATE INDEX idx_room_chat_user ON cinema.room_chat(user_id);
CREATE INDEX idx_room_chat_room_timestamp ON cinema.room_chat(room_id, sent_at);
CREATE INDEX idx_room_chat_reply ON cinema.room_chat(reply_to_id);

-- Отображения
-- Активные комнаты с детальной статистикой
CREATE VIEW cinema.active_rooms_view AS
SELECT 
    r.id AS room_id,
    r.name AS room_name,
    r.status,
    r.is_open,
    r.created_at,
    u.name AS owner_name,
    COUNT(DISTINCT rp.user_id) AS participants_count,
    COUNT(DISTINCT sm.movie_id) AS suggested_movies_count
FROM cinema.room r
JOIN cinema.user u ON r.owner_id = u.id
LEFT JOIN cinema.room_participant rp ON r.id = rp.room_id AND rp.is_active = TRUE
LEFT JOIN cinema.suggested_movie sm ON r.id = sm.room_id AND sm.is_active = TRUE
WHERE r.status != 'finished'
GROUP BY r.id, u.name;

-- Детальная статистика пользователей
CREATE VIEW cinema.user_stats_view AS
SELECT 
    u.id AS user_id,
    u.name AS user_name,
    u.overall_rating,
    u.registered_at,
    us.movies_suggested,
    us.movies_selected,
    us.total_ratings_received,
    COUNT(DISTINCT r.id) AS rooms_created,
    COUNT(DISTINCT rp.room_id) AS rooms_participated
FROM cinema.user u
LEFT JOIN cinema.user_statistic us ON u.id = us.user_id
LEFT JOIN cinema.room r ON u.id = r.owner_id
LEFT JOIN cinema.room_participant rp ON u.id = rp.user_id AND rp.is_active = TRUE
GROUP BY u.id, us.movies_suggested, us.movies_selected, us.total_ratings_received;

-- Триггеры

-- Таблица для аудита изменений
CREATE TABLE cinema.audit_log (
    id SERIAL PRIMARY KEY,
    table_name VARCHAR(50) NOT NULL,
    record_id INT NOT NULL,
    action VARCHAR(10) NOT NULL CHECK (action IN ('INSERT', 'UPDATE', 'DELETE')),
    old_values JSONB,
    new_values JSONB,
    changed_by INT REFERENCES cinema.user(id),
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Автоматическое создание записи статистики при регистрации пользователя
CREATE OR REPLACE FUNCTION cinema.create_user_stats()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO cinema.user_statistic (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_stats
    AFTER INSERT ON cinema.user
    FOR EACH ROW EXECUTE FUNCTION cinema.create_user_stats();

-- Обновление overall_rating при новой оценке
CREATE OR REPLACE FUNCTION cinema.update_user_rating()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE cinema.user 
    SET overall_rating = (
        SELECT AVG(rating)::DECIMAL(3,2)
        FROM cinema.review 
        WHERE to_user_id = NEW.to_user_id
    )
    WHERE id = NEW.to_user_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_user_rating
    AFTER INSERT ON cinema.review
    FOR EACH ROW EXECUTE FUNCTION cinema.update_user_rating();

-- Создание комнаты с автоматической генерацией кода доступа
CREATE OR REPLACE FUNCTION cinema.create_room(
    room_name VARCHAR(15),
    owner_id INT,
    is_open BOOLEAN DEFAULT TRUE
) RETURNS TABLE(room_id INT, access_code VARCHAR(7)) AS $$
DECLARE
    new_room_id INT;
    generated_code VARCHAR(7);
BEGIN
    -- Генерация случайного кода
    generated_code := UPPER(SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 6));
    
    INSERT INTO cinema.room (name, owner_id, is_open, access_code)
    VALUES (room_name, owner_id, is_open, generated_code)
    RETURNING id INTO new_room_id;
    
    -- Владелец автоматически становится участником
    INSERT INTO cinema.room_participant (room_id, user_id, role)
    VALUES (new_room_id, owner_id, 'moderator');
    
    RETURN QUERY SELECT new_room_id, generated_code;
END;
$$ LANGUAGE plpgsql;

-- Миграционная схема
CREATE TABLE cinema.schema_version (
    version INT PRIMARY KEY,
    description TEXT,
    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO cinema.schema_version (version, description) 
VALUES (1, 'Initial schema setup');

-- Тестовые данные
-- Вставка тестовых жанров
INSERT INTO cinema.genre (name, description) VALUES
('Action', 'Films with high-energy physical stunts and chases'),
('Comedy', 'Humorous and amusing films'),
('Drama', 'Serious, character-driven stories'),
('Sci-Fi', 'Science fiction and futuristic themes'),
('Horror', 'Scary and suspenseful films'),
('Romance', 'Love stories and romantic relationships'),
('Thriller', 'Suspenseful and exciting plots'),
('Fantasy', 'Magical and supernatural elements');

-- Тестовый пользователь
INSERT INTO cinema.user (name, email, password_hash) 
VALUES ('Admin', 'admin@cinema.com', 'hashed_password');

-- 1. Удаляем старый constraint (если он есть)
ALTER TABLE cinema.room_participant 
DROP CONSTRAINT IF EXISTS valid_role;

-- 2. Создаем новый constraint с разрешением роли 'owner'
ALTER TABLE cinema.room_participant 
ADD CONSTRAINT valid_role CHECK (role IN ('member', 'moderator', 'owner'));

ALTER TABLE cinema.movie 
ADD COLUMN IF NOT EXISTS rating_kp DECIMAL(3,1),
ADD COLUMN IF NOT EXISTS votes_kp INT;


-- Добавляем поле last_updated для отслеживания изменений
ALTER TABLE cinema."user" 
ADD COLUMN IF NOT EXISTS last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP;

-- Создаем триггер для автоматического обновления last_updated
CREATE OR REPLACE FUNCTION cinema.update_user_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.last_updated = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_update_user_timestamp ON cinema."user";
CREATE TRIGGER trigger_update_user_timestamp
    BEFORE UPDATE ON cinema."user"
    FOR EACH ROW
    EXECUTE FUNCTION cinema.update_user_timestamp();